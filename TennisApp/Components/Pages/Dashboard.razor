@page "/"
@inject NavigationManager NavigationManager
@rendermode InteractiveServer
@using TennisApp.Models
@using System.Text.Json
@using Newtonsoft.Json
@inject HttpClient Http
@inject IJSRuntime JSRuntime

<div class="page-container">
    <div class="header">
        <h1>Tennis Matches Dashboard</h1>
    </div>

    <div class="dashboard-section">
        <h2>Ongoing Matches</h2>
        @if (ongoingMatches == null || !ongoingMatches.Any())
        {
            <div class="loading-spinner-container">
                <div class="loading-spinner"></div>
                <div class="loading-text">Loading ongoing matches...</div>
            </div>
        }
        else
        {
            <div class="carousel-container">
                <button class="carousel-control left"
                        @onclick="() => NavigateCarousel(ongoingMatches, ongoingCurrentPage - 1, ref ongoingCurrentPage, ref ongoingTranslateX)">
                    <span>&lt;</span>
                </button>
                <div class="carousel">
                    @{
                        int ongoingTotalPages = (int)Math.Ceiling(ongoingMatches.Count / (double)CardsPerPage);
                    }

                    <div class="cards-wrapper" style="transform: translateX(@(ongoingTranslateX)px);">
                        @foreach (var match in ongoingMatches)
                        {
                            <div class="match-card ongoing">
                                <div class="match-card-header">
                                    <div class="match-time">@match.MatchTime.ToString("MMM dd, HH:mm")</div>
                                    <div class="match-location">@(match.Court?.Name ?? "Court TBD")</div>
                                </div>
                                <div class="player player-top">
                                    <div class="player-info">
                                        <div class="player-name">@(match.Player1?.Name ?? "Player 1")</div>
                                        @if (!string.IsNullOrEmpty(match.Player1?.Country))
                                        {
                                            <div class="player-country">@match.Player1.Country</div>
                                        }
                                    </div>
                                    <div class="player-score">
                                        @foreach (var set in match.Sets)
                                        {
                                            <span class="set-score">@set.Player1Games</span>
                                        }
                                    </div>
                                </div>
                                <div class="match-vs">VS</div>
                                <div class="player player-bottom">
                                    <div class="player-info">
                                        <div class="player-name">@(match.Player2?.Name ?? "Player 2")</div>
                                        @if (!string.IsNullOrEmpty(match.Player2?.Country))
                                        {
                                            <div class="player-country">@match.Player2.Country</div>
                                        }
                                    </div>
                                    <div class="player-score">
                                        @foreach (var set in match.Sets)
                                        {
                                            <span class="set-score">@set.Player2Games</span>
                                        }
                                    </div>
                                </div>
                                <div class="match-footer">
                                    <div class="match-status @(IsMatchLive(match) ? "status-live" : "status-live")">
                                        @(IsMatchLive(match) ? "LIVE" : "Starting soon")
                                    </div>
                                    <div class="match-sets">
                                        Set @match.Sets.Count of @GetMaxSets(match)
                                    </div>
                                </div>
                            </div>
                        }
                    </div>
                </div>
                <button class="carousel-control right"
                        @onclick="() => NavigateCarousel(ongoingMatches, ongoingCurrentPage + 1, ref ongoingCurrentPage, ref ongoingTranslateX)">
                    <span>&gt;</span>
                </button>
            </div>
            <div class="pagination-indicator">
                @for (int i = 1; i <= ongoingTotalPages; i++)
                {
                    int pageNumber = i;
                    <span class="page-dot @(ongoingCurrentPage == pageNumber ? "active" : "")"
                          @onclick="() => NavigateToPage(ongoingMatches, pageNumber, ref ongoingCurrentPage, ref ongoingTranslateX)"></span>
                }
            </div>
        }
    </div>

    <div class="dashboard-section">
        <h2>Upcoming Matches</h2>
        @if (upcomingMatches == null || !upcomingMatches.Any())
        {
            <div class="loading-spinner-container">
                <div class="loading-spinner"></div>
                <div class="loading-text">Loading upcoming matches...</div>
            </div>
        }
        else
        {
            <div class="carousel-container">
                <button class="carousel-control left"
                        @onclick="() => NavigateCarousel(upcomingMatches, upcomingCurrentPage - 1, ref upcomingCurrentPage, ref upcomingTranslateX)">
                    <span>&lt;</span>
                </button>
                <div class="carousel">
                    @{
                        int upcomingTotalPages = (int)Math.Ceiling(upcomingMatches.Count / (double)CardsPerPage);
                    }

                    <div class="cards-wrapper" style="transform: translateX(@(upcomingTranslateX)px);">
                        @foreach (var match in upcomingMatches)
                        {
                            <div class="match-card upcoming">
                                <div class="match-card-header">
                                    <div class="match-time">@match.MatchTime.ToString("MMM dd, HH:mm")</div>
                                    <div class="match-location">@(match.Court?.Name ?? "Court TBD")</div>
                                </div>
                                <div class="player player-top">
                                    <div class="player-info">
                                        <div class="player-name">@(match.Player1?.Name ?? "Player 1")</div>
                                        @if (!string.IsNullOrEmpty(match.Player1?.Country))
                                        {
                                            <div class="player-country">@match.Player1.Country</div>
                                        }
                                    </div>
                                </div>
                                <div class="match-vs">VS</div>
                                <div class="player player-bottom">
                                    <div class="player-info">
                                        <div class="player-name">@(match.Player2?.Name ?? "Player 2")</div>
                                        @if (!string.IsNullOrEmpty(match.Player2?.Country))
                                        {
                                            <div class="player-country">@match.Player2.Country</div>
                                        }
                                    </div>
                                </div>
                                <div class="match-footer">
                                    <div class="match-countdown">
                                        @GetCountdownText(match.MatchTime)
                                    </div>
                                    <div class="match-court-type">
                                        @(match.Court?.IsIndoor == true ? "Indoor" : "Outdoor")
                                    </div>
                                </div>
                            </div>
                        }
                    </div>
                </div>
                <button class="carousel-control right"
                        @onclick="() => NavigateCarousel(upcomingMatches, upcomingCurrentPage + 1, ref upcomingCurrentPage, ref upcomingTranslateX)">
                    <span>&gt;</span>
                </button>
            </div>
            <div class="pagination-indicator">
                @for (int i = 1; i <= upcomingTotalPages; i++)
                {
                    int pageNumber = i;
                    <span class="page-dot @(upcomingCurrentPage == pageNumber ? "active" : "")"
                          @onclick="() => NavigateToPage(upcomingMatches, pageNumber, ref upcomingCurrentPage, ref upcomingTranslateX)"></span>
                }
            </div>
        }
    </div>

    <div class="dashboard-section">
        <h2>Finished Matches</h2>
        @if (finishedMatches == null || !finishedMatches.Any())
        {
            <div class="loading-spinner-container">
                <div class="loading-spinner"></div>
                <div class="loading-text">Loading finished matches...</div>
            </div>
        }
        else
        {
            <div class="carousel-container">
                <button class="carousel-control left"
                        @onclick="() => NavigateCarousel(finishedMatches, finishedCurrentPage - 1, ref finishedCurrentPage, ref finishedTranslateX)">
                    <span>&lt;</span>
                </button>
                <div class="carousel">
                    @{
                        int finishedTotalPages = (int)Math.Ceiling(finishedMatches.Count / (double)CardsPerPage);
                    }

                    <div class="cards-wrapper" style="transform: translateX(@(finishedTranslateX)px);">
                        @foreach (var match in finishedMatches)
                        {
                            <div class="match-card completed">
                                <div class="match-card-header">
                                    <div class="match-time">@match.MatchTime.ToString("MMM dd, HH:mm")</div>
                                    <div class="match-location">@(match.Court?.Name ?? "Court TBD")</div>
                                </div>
                                <div class="player player-top @(IsPlayerWinner(match, match.Player1?.Id) ? "winner" : "")">
                                    <div class="player-info">
                                        <div class="player-name">@(match.Player1?.Name ?? "Player 1")</div>
                                        @if (!string.IsNullOrEmpty(match.Player1?.Country))
                                        {
                                            <div class="player-country">@match.Player1.Country</div>
                                        }
                                    </div>
                                    <div class="player-score">
                                        @foreach (var set in match.Sets)
                                        {
                                            <span class="set-score">@set.Player1Games</span>
                                        }
                                    </div>
                                </div>
                                <div class="match-vs">VS</div>
                                <div class="player player-bottom @(IsPlayerWinner(match, match.Player2?.Id) ? "winner" : "")">
                                    <div class="player-info">
                                        <div class="player-name">@(match.Player2?.Name ?? "Player 2")</div>
                                        @if (!string.IsNullOrEmpty(match.Player2?.Country))
                                        {
                                            <div class="player-country">@match.Player2.Country</div>
                                        }
                                    </div>
                                    <div class="player-score">
                                        @foreach (var set in match.Sets)
                                        {
                                            <span class="set-score">@set.Player2Games</span>
                                        }
                                    </div>
                                </div>
                                <div class="match-footer">
                                    <div class="match-status completed-status">
                                        Completed
                                    </div>
                                    <div class="match-sets">
                                        @GetMatchResult(match)
                                    </div>
                                </div>
                            </div>
                        }
                    </div>
                </div>
                <button class="carousel-control right"
                        @onclick="() => NavigateCarousel(finishedMatches, finishedCurrentPage + 1, ref finishedCurrentPage, ref finishedTranslateX)">
                    <span>&gt;</span>
                </button>
            </div>
            <div class="pagination-indicator">
                @for (int i = 1; i <= finishedTotalPages; i++)
                {
                    int pageNumber = i;
                    <span class="page-dot @(finishedCurrentPage == pageNumber ? "active" : "")"
                          @onclick="() => NavigateToPage(finishedMatches, pageNumber, ref finishedCurrentPage, ref finishedTranslateX)"></span>
                }
            </div>
        }
    </div>
</div>

@code {
    private List<MatchViewModel> allMatches = new List<MatchViewModel>();
    private List<MatchViewModel> ongoingMatches = new List<MatchViewModel>();
    private List<MatchViewModel> upcomingMatches = new List<MatchViewModel>();
    private List<MatchViewModel> finishedMatches = new List<MatchViewModel>();

    // Carousel pagination state
    private int ongoingCurrentPage = 1;
    private int upcomingCurrentPage = 1;
    private int finishedCurrentPage = 1;

    // Carousel animation state (translateX values)
    private int ongoingTranslateX = 0;
    private int upcomingTranslateX = 0;
    private int finishedTranslateX = 0;

    private const int CardsPerPage = 4;
    // Width of each card plus gap (calculated from CSS)
    private const int CardWidth = 350; // Wider base card width
    private const int CardGap = 24; // Gap between cards (1.5rem = 24px)
    private const int TotalCardWidth = CardWidth + CardGap;

    protected override async Task OnInitializedAsync()
    {
        await LoadMatches();
    }

    // Replace the LoadMatches method with this updated version

    private async Task LoadMatches()
    {
        try
        {
            var response = await Http.GetAsync("api/matches");
            if (response.IsSuccessStatusCode)
            {
                var content = await response.Content.ReadAsStringAsync();

                try
                {
                    // Use System.Text.Json instead of Newtonsoft.Json
                    var options = new JsonSerializerOptions
                        {
                            PropertyNameCaseInsensitive = true
                        };

                    using (var jsonDoc = JsonDocument.Parse(content))
                    {
                        var root = jsonDoc.RootElement;

                        if (root.TryGetProperty("$values", out var valuesElement))
                        {
                            allMatches = new List<MatchViewModel>();

                            foreach (var matchElement in valuesElement.EnumerateArray())
                            {
                                var match = new MatchViewModel
                                    {
                                        Id = matchElement.GetProperty("id").GetInt32(),
                                        MatchTime = matchElement.GetProperty("matchTime").GetDateTime(),
                                        Sets = new List<SetViewModel>()
                                    };

                                // Parse court
                                if (matchElement.TryGetProperty("court", out var courtElement) &&
                                    courtElement.ValueKind != JsonValueKind.Null)
                                {
                                    match.Court = new CourtViewModel
                                        {
                                            Id = courtElement.GetProperty("id").GetInt32(),
                                            Name = courtElement.GetProperty("name").GetString(),
                                            IsIndoor = courtElement.GetProperty("isIndoor").GetBoolean()
                                        };
                                }

                                // Parse player1
                                if (matchElement.TryGetProperty("player1", out var player1Element) &&
                                    player1Element.ValueKind != JsonValueKind.Null)
                                {
                                    match.Player1 = new PlayerViewModel
                                        {
                                            Id = player1Element.GetProperty("id").GetInt32(),
                                            Name = player1Element.GetProperty("name").GetString()
                                        };

                                    if (player1Element.TryGetProperty("country", out var countryElement) &&
                                        countryElement.ValueKind != JsonValueKind.Null)
                                    {
                                        match.Player1.Country = countryElement.GetString();
                                    }
                                }

                                // Parse player2
                                if (matchElement.TryGetProperty("player2", out var player2Element) &&
                                    player2Element.ValueKind != JsonValueKind.Null)
                                {
                                    match.Player2 = new PlayerViewModel
                                        {
                                            Id = player2Element.GetProperty("id").GetInt32(),
                                            Name = player2Element.GetProperty("name").GetString()
                                        };

                                    if (player2Element.TryGetProperty("country", out var countryElement) &&
                                        countryElement.ValueKind != JsonValueKind.Null)
                                    {
                                        match.Player2.Country = countryElement.GetString();
                                    }
                                }

                                // Parse sets
                                if (matchElement.TryGetProperty("sets", out var setsElement) &&
                                    setsElement.ValueKind != JsonValueKind.Null &&
                                    setsElement.TryGetProperty("$values", out var setsValuesElement))
                                {
                                    foreach (var setElement in setsValuesElement.EnumerateArray())
                                    {
                                        var setViewModel = new SetViewModel
                                            {
                                                Id = setElement.GetProperty("id").GetInt32(),
                                                SetNumber = setElement.GetProperty("setNumber").GetInt32(),
                                                Player1Games = setElement.GetProperty("player1Games").GetInt32(),
                                                Player2Games = setElement.GetProperty("player2Games").GetInt32(),
                                                IsCompleted = setElement.GetProperty("isCompleted").GetBoolean()
                                            };

                                        if (setElement.TryGetProperty("winnerId", out var winnerIdElement) &&
                                            winnerIdElement.ValueKind != JsonValueKind.Null)
                                        {
                                            setViewModel.WinnerId = winnerIdElement.GetInt32();
                                        }

                                        match.Sets.Add(setViewModel);
                                    }
                                }

                                allMatches.Add(match);
                            }
                        }
                        else
                        {
                            // If there's no $values property, try parsing as a direct array
                            allMatches = System.Text.Json.JsonSerializer.Deserialize<List<MatchViewModel>>(content, options) ?? new List<MatchViewModel>();
                        }
                    }

                    Console.WriteLine($"Successfully parsed {allMatches.Count} matches");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"JSON parsing error: {ex.Message}");
                    Console.WriteLine($"JSON content: {content.Substring(0, Math.Min(500, content.Length))}...");

                    // As a last resort, try deserializing with Newtonsoft directly to List<MatchViewModel>
                    try
                    {
                        var settings = new Newtonsoft.Json.JsonSerializerSettings
                            {
                                ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore,
                                NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore
                            };

                        // Try to deserialize directly to a list instead of using the ReferenceList wrapper
                        // This might work if the JSON is actually an array of matches at the root level
                        var jsonObject = Newtonsoft.Json.JsonConvert.DeserializeObject<dynamic>(content, settings);

                        if (jsonObject?.GetProperty("$values") != null)
                        {
                            // If it has a $values property, extract that
                            allMatches = Newtonsoft.Json.JsonConvert.DeserializeObject<List<MatchViewModel>>(
                                Newtonsoft.Json.JsonConvert.SerializeObject(jsonObject["$values"]), settings);
                        }
                        else
                        {
                            // Otherwise, try deserializing the whole thing as a list
                            allMatches = Newtonsoft.Json.JsonConvert.DeserializeObject<List<MatchViewModel>>(content, settings) ?? new List<MatchViewModel>();
                        }
                    }
                    catch (Exception fallbackEx)
                    {
                        Console.WriteLine($"Fallback parsing also failed: {fallbackEx.Message}");
                        allMatches = new List<MatchViewModel>();
                    }
                }

                // Get current time for comparison
                var currentTime = DateTime.Now;

                // Apply the updated match classification logic
                // Upcoming: Matches with no sets AND match time is more than 10 minutes in the future
                upcomingMatches = allMatches
                .Where(m => (m.Sets == null || !m.Sets.Any()) &&
                m.MatchTime > currentTime.AddMinutes(10))
                .OrderBy(m => m.MatchTime)
                .ToList();

                // Ongoing:
                // 1. Matches with sets but none finished yet OR
                // 2. Matches with no sets but match time is within 10 minutes from now or has already passed
                ongoingMatches = allMatches
                .Where(m => (m.Sets != null && m.Sets.Any() && !IsMatchCompleted(m)) ||
                ((m.Sets == null || !m.Sets.Any()) &&
                m.MatchTime <= currentTime.AddMinutes(10)))
                .OrderBy(m => m.MatchTime)
                .ToList();

                // Finished: Matches where all sets are completed and at least 2 sets have the same winnerId
                finishedMatches = allMatches
                .Where(m => IsMatchCompleted(m))
                .OrderByDescending(m => m.MatchTime) // Most recent first
                .ToList();

                Console.WriteLine($"Categorized matches: {upcomingMatches.Count} upcoming, {ongoingMatches.Count} ongoing, {finishedMatches.Count} finished");
            }
            else
            {
                Console.WriteLine($"Error loading matches: {response.StatusCode}");
                Console.WriteLine($"Response content: {await response.Content.ReadAsStringAsync()}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Exception while loading matches: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
        }
    }

    // Also update the ReferenceList class to match the JSON structure better
    public class ReferenceList<T>
    {
        [Newtonsoft.Json.JsonProperty("$id")]
        public string? Id { get; set; }

        [Newtonsoft.Json.JsonProperty("$values")]
        public List<T> Values { get; set; } = new List<T>();
    }

    public class MatchViewModel
    {
        [Newtonsoft.Json.JsonProperty("id")]
        public int Id { get; set; }

        [Newtonsoft.Json.JsonProperty("matchTime")]
        public DateTime MatchTime { get; set; }

        [Newtonsoft.Json.JsonProperty("court")]
        public CourtViewModel? Court { get; set; }

        [Newtonsoft.Json.JsonProperty("player1")]
        public PlayerViewModel? Player1 { get; set; }

        [Newtonsoft.Json.JsonProperty("player2")]
        public PlayerViewModel? Player2 { get; set; }

        [Newtonsoft.Json.JsonProperty("sets")]
        public List<SetViewModel> Sets { get; set; } = new List<SetViewModel>();
    }

    public class CourtViewModel
    {
        [Newtonsoft.Json.JsonProperty("id")]
        public int Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name")]
        public string? Name { get; set; }

        [Newtonsoft.Json.JsonProperty("isIndoor")]
        public bool IsIndoor { get; set; }
    }

    public class PlayerViewModel
    {
        [Newtonsoft.Json.JsonProperty("id")]
        public int Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name")]
        public string? Name { get; set; }

        [Newtonsoft.Json.JsonProperty("country")]
        public string? Country { get; set; }
    }

    public class SetViewModel
    {
        [Newtonsoft.Json.JsonProperty("id")]
        public int Id { get; set; }

        [Newtonsoft.Json.JsonProperty("setNumber")]
        public int SetNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("player1Games")]
        public int Player1Games { get; set; }

        [Newtonsoft.Json.JsonProperty("player2Games")]
        public int Player2Games { get; set; }

        [Newtonsoft.Json.JsonProperty("isCompleted")]
        public bool IsCompleted { get; set; }

        [Newtonsoft.Json.JsonProperty("winnerId")]
        public int? WinnerId { get; set; }
    }

    private void NavigateCarousel(List<MatchViewModel> matches, int targetPage, ref int currentPage, ref int translateX)
    {
        int totalPages = (int)Math.Ceiling(matches.Count / (double)CardsPerPage);

        if (targetPage < 1)
            targetPage = totalPages; // Wrap to last page
        else if (targetPage > totalPages)
            targetPage = 1; // Wrap to first page

        // Calculate the new translateX value
        int newTranslateX = -(targetPage - 1) * CardsPerPage * TotalCardWidth;

        // Add animation class
        currentPage = targetPage;
        translateX = newTranslateX;

        StateHasChanged();
    }

    private void NavigateToPage(List<MatchViewModel> matches, int pageNumber, ref int currentPage, ref int translateX)
    {
        currentPage = pageNumber;
        translateX = -(pageNumber - 1) * CardsPerPage * TotalCardWidth;
        StateHasChanged();
    }

    private bool IsMatchCompleted(MatchViewModel match)
    {
        // Updated match completion logic:
        // 1. All sets must be completed
        // 2. At least 2 sets must have the same winnerId

        if (match.Sets == null || !match.Sets.Any())
            return false;

        // Check if all sets are completed first
        if (match.Sets.Any(s => !s.IsCompleted))
            return false;

        // Count wins for each player
        int? player1Id = match.Player1?.Id;
        int? player2Id = match.Player2?.Id;

        int player1Wins = match.Sets.Count(s => s.WinnerId == player1Id);
        int player2Wins = match.Sets.Count(s => s.WinnerId == player2Id);

        // Match is completed if either player has at least 2 set wins
        return player1Wins >= 2 || player2Wins >= 2;
    }

    private bool IsPlayerWinner(MatchViewModel match, int? playerId)
    {
        if (match.Sets == null || !match.Sets.Any() || playerId == null)
            return false;

        int playerSets = match.Sets.Count(s => s.IsCompleted && s.WinnerId == playerId);
        int opponentSets = match.Sets.Count(s => s.IsCompleted && s.WinnerId != null && s.WinnerId != playerId);

        return playerSets > opponentSets;
    }

    private bool IsMatchLive(MatchViewModel match)
    {
        return match.Sets != null && match.Sets.Any(s => !s.IsCompleted);
    }

    private int GetMaxSets(MatchViewModel match)
    {
        return 3;
    }

    private string GetCountdownText(DateTime matchTime)
    {
        var timeUntilMatch = matchTime - DateTime.Now;

        if (timeUntilMatch.TotalDays >= 1)
        {
            return $"In {(int)timeUntilMatch.TotalDays} day{(timeUntilMatch.TotalDays >= 2 ? "s" : "")}";
        }
        else if (timeUntilMatch.TotalHours >= 1)
        {
            return $"In {(int)timeUntilMatch.TotalHours} hour{(timeUntilMatch.TotalHours >= 2 ? "s" : "")}";
        }
        else
        {
            return $"In {(int)timeUntilMatch.TotalMinutes} minute{(timeUntilMatch.TotalMinutes >= 2 ? "s" : "")}";
        }
    }

    private string GetMatchResult(MatchViewModel match)
    {
        if (match.Sets == null || !match.Sets.Any())
            return "No result";

        int player1Sets = match.Sets.Count(s => s.IsCompleted && s.WinnerId == match.Player1?.Id);
        int player2Sets = match.Sets.Count(s => s.IsCompleted && s.WinnerId == match.Player2?.Id);

        return $"{player1Sets}-{player2Sets}";
    }
}