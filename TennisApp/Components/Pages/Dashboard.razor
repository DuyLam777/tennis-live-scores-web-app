@page "/"
@inject NavigationManager NavigationManager
@rendermode InteractiveServer
@using TennisApp.Models
@using System.Text.Json
@using Newtonsoft.Json
@using Newtonsoft.Json
@inject HttpClient Http
@inject IJSRuntime JSRuntime

<div class="page-container">
    <div class="header">
        <h1>Tennis Matches Dashboard</h1>
    </div>

    <div class="dashboard-controls">
        <div class="search-container">
            <input type="text" placeholder="Search by player name..." @bind-value="searchTerm"
                @oninput="OnSearchInput" />
            <button class="clear-search" @onclick="ClearSearch">Ã—</button>
        </div>
    </div>

    <div class="dashboard-section">
        <h2>All matches @(filteredMatches.Count != allMatches.Count ? $"({filteredMatches.Count} of {allMatches.Count})"
                        : "")</h2>
            @if (allMatches == null || !allMatches.Any())
            {
                <div class="loading-spinner-container">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">Loading ongoing matches...</div>
                </div>
            }
            else if (filteredMatches.Count == 0)
            {
                <div class="no-results">
                    <p>No matches found for "@searchTerm"</p>
                    <button @onclick="ClearSearch">Clear search</button>
                </div>
            }
            else
            {
                <div class="match-list-wrapper" @ref="matchListContainer">
                    <div class="match-list">
                        @foreach (var match in filteredMatches)
                        {
                            string matchStatus = GetMatchStatus(match);
                            
                            <div class="match-card @matchStatus @(isLiveMatchRef(match) ? "current-focus" : "")">
                                <div class="match-card-header">
                                    <div class="match-time">@match.MatchTime.ToString("MMM dd, HH:mm")</div>
                                    <div class="match-location">@(match.Court?.Name ?? "Court TBD")</div>
                                    <div class="match-status @(matchStatus == "upcoming" ? "" :
                                        matchStatus == "completed" ? "completed-status" : "status-live")">
                                        @(matchStatus == "upcoming" ? GetCountdownText(match.MatchTime) :
                                        matchStatus == "completed" ? "Finished" : IsMatchLive(match) ? "Live" : "Starting soon")
                                    </div>
                                    <div class="match-sets">
                                        Set @match.Sets.Count of @GetMaxSets(match)
                                    </div>
                                </div>

                                <div class="match-players">
                                    <!-- Left player with name on left, score on right -->
                                    <div class="player player-left">
                                        <div class="player-info">
                                            <div class="player-name">@(match.Player1?.Name ?? "Player 1")</div>
                                            @if (!string.IsNullOrEmpty(match.Player1?.Country))
                                            {
                                                <div class="player-country">@match.Player1.Country</div>
                                            }
                                        </div>
                                        <div class="player-score player-score-left">
                                            @foreach (var set in match.Sets)
                                            {
                                                <span class="set-score">@set.Player1Games</span>
                                            }
                                        </div>
                                    </div>

                                    <!-- VS in middle, absolutely positioned to ensure perfect center alignment -->
                                    <div class="match-vs">VS</div>

                                    <!-- Right player with score on left, name on right -->
                                    <div class="player player-right">
                                        <div class="player-score player-score-right">
                                            @foreach (var set in match.Sets)
                                            {
                                                <span class="set-score">@set.Player2Games</span>
                                            }
                                        </div>
                                        <div class="player-info">
                                            <div class="player-name">@(match.Player2?.Name ?? "Player 2")</div>
                                            @if (!string.IsNullOrEmpty(match.Player2?.Country))
                                            {
                                                <div class="player-country">@match.Player2.Country</div>
                                            }
                                        </div>
                                    </div>
                                </div>
                            </div>
                        }
                    </div>
                </div>
            }
    </div>
</div>

@code {
    private List<MatchViewModel> allMatches = new List<MatchViewModel>();
    private List<MatchViewModel> filteredMatches = new List<MatchViewModel>();
    private string searchTerm = "";
    private string sortOption = "timeAsc";
    
    // Added for scrolling functionality
    private ElementReference matchListContainer;
    private MatchViewModel? liveMatchRef;
    
    // Check if a match is the one we want to highlight
    private bool isLiveMatchRef(MatchViewModel match)
    {
        return match == liveMatchRef;
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadMatches();
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // First render completed, now wait for matches to load
            await InvokeAsync(StateHasChanged);
        }
        else if (filteredMatches.Count > 0 && liveMatchRef == null)
        {
            // Find the first live match
            var firstLiveMatch = filteredMatches.FirstOrDefault(m => GetMatchStatus(m) == "ongoing");
            if (firstLiveMatch != null)
            {
                // Set the reference match to trigger highlighting in the UI
                liveMatchRef = firstLiveMatch;
                
                // Request a UI update to apply the current-focus class
                await InvokeAsync(StateHasChanged);
                
                // Use the browser's native scrollIntoView API
                try
                {
                    // Find the current-focus element and scroll to it
                    await JSRuntime.InvokeVoidAsync("eval", 
                        "setTimeout(() => { " +
                        "  const element = document.querySelector('.current-focus'); " +
                        "  if (element) { " +
                        "    element.scrollIntoView({ behavior: 'smooth', block: 'center' }); " +
                        "  }" +
                        "}, 100);");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error scrolling to match: {ex.Message}");
                }
            }
        }
    }

    protected override void OnParametersSet()
    {
        FilterMatches();
    }

    private void OnSearchInput(ChangeEventArgs e)
    {
        searchTerm = e.Value?.ToString() ?? "";
        FilterMatches();
    }

    private void OnSortChanged(ChangeEventArgs e)
    {
        sortOption = e.Value?.ToString() ?? "timeAsc";
        FilterMatches();
    }

    private void SortChanged(ChangeEventArgs e)
    {
        FilterMatches();
    }

    private void FilterMatches()
    {
        // Apply search filter
        var filtered = allMatches;

        if (!string.IsNullOrWhiteSpace(searchTerm))
        {
            string term = searchTerm.Trim().ToLower();
            filtered = filtered.Where(m =>
            (m.Player1?.Name?.ToLower()?.Contains(term) ?? false) ||
            (m.Player2?.Name?.ToLower()?.Contains(term) ?? false)
            ).ToList();
        }

        // Apply sorting
        switch (sortOption)
        {
            case "timeDesc":
                filtered = filtered.OrderByDescending(m => m.MatchTime).ToList();
                break;
            case "timeAsc":
            default:
                filtered = filtered.OrderBy(m => m.MatchTime).ToList();
                break;
        }

        filteredMatches = filtered;
        
        // Reset the live match reference when filters change
        liveMatchRef = null;
    }

    private void ClearSearch()
    {
        searchTerm = "";
        FilterMatches();
    }

    private async Task LoadMatches()
    {
        try
        {
            var response = await Http.GetAsync("api/matches");
            if (response.IsSuccessStatusCode)
            {
                var content = await response.Content.ReadAsStringAsync();

                try
                {
                    // Use System.Text.Json instead of Newtonsoft.Json
                    var options = new JsonSerializerOptions
                    {
                        PropertyNameCaseInsensitive = true
                    };

                    using (var jsonDoc = JsonDocument.Parse(content))
                    {
                        var root = jsonDoc.RootElement;

                        if (root.TryGetProperty("$values", out var valuesElement))
                        {
                            allMatches = new List<MatchViewModel>();

                            foreach (var matchElement in valuesElement.EnumerateArray())
                            {
                                var match = new MatchViewModel
                                {
                                    Id = matchElement.GetProperty("id").GetInt32(),
                                    MatchTime = matchElement.GetProperty("matchTime").GetDateTime(),
                                    Sets = new List<SetViewModel>()
                                };

                                // Parse court
                                if (matchElement.TryGetProperty("court", out var courtElement) &&
                                courtElement.ValueKind != JsonValueKind.Null)
                                {
                                    match.Court = new CourtViewModel
                                    {
                                        Id = courtElement.GetProperty("id").GetInt32(),
                                        Name = courtElement.GetProperty("name").GetString(),
                                        IsIndoor = courtElement.GetProperty("isIndoor").GetBoolean()
                                    };
                                }

                                // Parse player1
                                if (matchElement.TryGetProperty("player1", out var player1Element) &&
                                player1Element.ValueKind != JsonValueKind.Null)
                                {
                                    match.Player1 = new PlayerViewModel
                                    {
                                        Id = player1Element.GetProperty("id").GetInt32(),
                                        Name = player1Element.GetProperty("name").GetString()
                                    };

                                    if (player1Element.TryGetProperty("country", out var countryElement) &&
                                    countryElement.ValueKind != JsonValueKind.Null)
                                    {
                                        match.Player1.Country = countryElement.GetString();
                                    }
                                }

                                // Parse player2
                                if (matchElement.TryGetProperty("player2", out var player2Element) &&
                                player2Element.ValueKind != JsonValueKind.Null)
                                {
                                    match.Player2 = new PlayerViewModel
                                    {
                                        Id = player2Element.GetProperty("id").GetInt32(),
                                        Name = player2Element.GetProperty("name").GetString()
                                    };

                                    if (player2Element.TryGetProperty("country", out var countryElement) &&
                                    countryElement.ValueKind != JsonValueKind.Null)
                                    {
                                        match.Player2.Country = countryElement.GetString();
                                    }
                                }

                                // Parse sets
                                if (matchElement.TryGetProperty("sets", out var setsElement) &&
                                setsElement.ValueKind != JsonValueKind.Null &&
                                setsElement.TryGetProperty("$values", out var setsValuesElement))
                                {
                                    foreach (var setElement in setsValuesElement.EnumerateArray())
                                    {
                                        var setViewModel = new SetViewModel
                                        {
                                            Id = setElement.GetProperty("id").GetInt32(),
                                            SetNumber = setElement.GetProperty("setNumber").GetInt32(),
                                            Player1Games = setElement.GetProperty("player1Games").GetInt32(),
                                            Player2Games = setElement.GetProperty("player2Games").GetInt32(),
                                            IsCompleted = setElement.GetProperty("isCompleted").GetBoolean()
                                        };

                                        if (setElement.TryGetProperty("winnerId", out var winnerIdElement) &&
                                        winnerIdElement.ValueKind != JsonValueKind.Null)
                                        {
                                            setViewModel.WinnerId = winnerIdElement.GetInt32();
                                        }

                                        match.Sets.Add(setViewModel);
                                    }
                                }

                                allMatches.Add(match);
                            }
                        }
                        else
                        {
                            // If there's no $values property, try parsing as a direct array
                            allMatches = System.Text.Json.JsonSerializer.Deserialize<List<MatchViewModel>>(content, options) ?? new
                            List<MatchViewModel>();
                        }
                    }

                    Console.WriteLine($"Successfully parsed {allMatches.Count} matches");

                    // Initialize filtered matches
                    FilterMatches();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"JSON parsing error: {ex.Message}");
                    Console.WriteLine($"JSON content: {content.Substring(0, Math.Min(500, content.Length))}...");

                    // As a last resort, try deserializing with Newtonsoft directly to List<MatchViewModel>
                    try
                    {
                        var settings = new Newtonsoft.Json.JsonSerializerSettings
                        {
                            ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore,
                            NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore
                        };

                        // Try to deserialize directly to a list instead of using the ReferenceList wrapper
                        // This might work if the JSON is actually an array of matches at the root level
                        var jsonObject = Newtonsoft.Json.JsonConvert.DeserializeObject<dynamic>(content, settings);

                        if (jsonObject?.GetProperty("$values") != null)
                        {
                            // If it has a $values property, extract that
                            allMatches = Newtonsoft.Json.JsonConvert.DeserializeObject<List<MatchViewModel>>(
                            Newtonsoft.Json.JsonConvert.SerializeObject(jsonObject["$values"]), settings);
                        }
                        else
                        {
                            // Otherwise, try deserializing the whole thing as a list
                            allMatches = Newtonsoft.Json.JsonConvert.DeserializeObject<List<MatchViewModel>>(content, settings) ?? new
                            List<MatchViewModel>();
                        }

                        // Initialize filtered matches
                        FilterMatches();
                    }
                    catch (Exception fallbackEx)
                    {
                        Console.WriteLine($"Fallback parsing also failed: {fallbackEx.Message}");
                        allMatches = new List<MatchViewModel>();
                        filteredMatches = new List<MatchViewModel>();
                    }
                }
            }
            else
            {
                Console.WriteLine($"Error loading matches: {response.StatusCode}");
                Console.WriteLine($"Response content: {await response.Content.ReadAsStringAsync()}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Exception while loading matches: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
        }
    }

    private string GetMatchStatus(MatchViewModel m)
    {
        var currentTime = DateTime.Now;
        if ((m.Sets == null || !m.Sets.Any()) && m.MatchTime > currentTime.AddMinutes(10))
        {
            return "upcoming";
        }
        else if ((m.Sets != null && m.Sets.Any() && !IsMatchCompleted(m)) ||
        ((m.Sets == null || !m.Sets.Any()) &&
        m.MatchTime <= currentTime.AddMinutes(10)))
        {
            return "ongoing";
        }
        else if (IsMatchCompleted(m))
        {
            return "completed";
        }
        else
        {
            return "unknown";
        }
    }

    // Also update the ReferenceList class to match the JSON structure better
    public class ReferenceList<T>
    {
        [Newtonsoft.Json.JsonProperty("$id")]
        public string? Id { get; set; }

        [Newtonsoft.Json.JsonProperty("$values")]
        public List<T> Values { get; set; } = new List<T>();
    }

    public class MatchViewModel
    {
        [Newtonsoft.Json.JsonProperty("id")]
        public int Id { get; set; }

        [Newtonsoft.Json.JsonProperty("matchTime")]
        public DateTime MatchTime { get; set; }

        [Newtonsoft.Json.JsonProperty("court")]
        public CourtViewModel? Court { get; set; }

        [Newtonsoft.Json.JsonProperty("player1")]
        public PlayerViewModel? Player1 { get; set; }

        [Newtonsoft.Json.JsonProperty("player2")]
        public PlayerViewModel? Player2 { get; set; }

        [Newtonsoft.Json.JsonProperty("sets")]
        public List<SetViewModel> Sets { get; set; } = new List<SetViewModel>();
    }

    public class CourtViewModel
    {
        [Newtonsoft.Json.JsonProperty("id")]
        public int Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name")]
        public string? Name { get; set; }

        [Newtonsoft.Json.JsonProperty("isIndoor")]
        public bool IsIndoor { get; set; }
    }

    public class PlayerViewModel
    {
        [Newtonsoft.Json.JsonProperty("id")]
        public int Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name")]
        public string? Name { get; set; }

        [Newtonsoft.Json.JsonProperty("country")]
        public string? Country { get; set; }
    }

    public class SetViewModel
    {
        [Newtonsoft.Json.JsonProperty("id")]
        public int Id { get; set; }

        [Newtonsoft.Json.JsonProperty("setNumber")]
        public int SetNumber { get; set; }

        [Newtonsoft.Json.JsonProperty("player1Games")]
        public int Player1Games { get; set; }

        [Newtonsoft.Json.JsonProperty("player2Games")]
        public int Player2Games { get; set; }

        [Newtonsoft.Json.JsonProperty("isCompleted")]
        public bool IsCompleted { get; set; }

        [Newtonsoft.Json.JsonProperty("winnerId")]
        public int? WinnerId { get; set; }
    }

    private bool IsMatchCompleted(MatchViewModel match)
    {
        // Updated match completion logic:
        // 1. All sets must be completed
        // 2. At least 2 sets must have the same winnerId

        if (match.Sets == null || !match.Sets.Any())
            return false;

        // Check if all sets are completed first
        if (match.Sets.Any(s => !s.IsCompleted))
            return false;

        // Count wins for each player
        int? player1Id = match.Player1?.Id;
        int? player2Id = match.Player2?.Id;

        int player1Wins = match.Sets.Count(s => s.WinnerId == player1Id);
        int player2Wins = match.Sets.Count(s => s.WinnerId == player2Id);

        // Match is completed if either player has at least 2 set wins
        return player1Wins >= 2 || player2Wins >= 2;
    }

    private bool IsPlayerWinner(MatchViewModel match, int? playerId)
    {
        if (match.Sets == null || !match.Sets.Any() || playerId == null)
            return false;

        int playerSets = match.Sets.Count(s => s.IsCompleted && s.WinnerId == playerId);
        int opponentSets = match.Sets.Count(s => s.IsCompleted && s.WinnerId != null && s.WinnerId != playerId);

        return playerSets > opponentSets;
    }

    private bool IsMatchLive(MatchViewModel match)
    {
        return match.Sets != null && match.Sets.Any(s => !s.IsCompleted);
    }

    private int GetMaxSets(MatchViewModel match)
    {
        return 3;
    }

    private string GetCountdownText(DateTime matchTime)
    {
        var timeUntilMatch = matchTime - DateTime.Now;

        if (timeUntilMatch.TotalDays >= 1)
        {
            return $"In {(int)timeUntilMatch.TotalDays} day{(timeUntilMatch.TotalDays >= 2 ? "s" : "")}";
        }
        else if (timeUntilMatch.TotalHours >= 1)
        {
            return $"In {(int)timeUntilMatch.TotalHours} hour{(timeUntilMatch.TotalHours >= 2 ? "s" : "")}";
        }
        else
        {
            return $"In {(int)timeUntilMatch.TotalMinutes} minute{(timeUntilMatch.TotalMinutes >= 2 ? "s" : "")}";
        }
    }

    private string GetMatchResult(MatchViewModel match)
    {
        if (match.Sets == null || !match.Sets.Any())
            return "No result";

        int player1Sets = match.Sets.Count(s => s.IsCompleted && s.WinnerId == match.Player1?.Id);
        int player2Sets = match.Sets.Count(s => s.IsCompleted && s.WinnerId == match.Player2?.Id);

        return $"{player1Sets}-{player2Sets}";
    }
}